{
  "language": "Solidity",
  "sources": {
    "contracts/ERC20Registry.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/// @title ERC20Registry\n/// @author Paul Czajka [paul.czajka@gmail.com]\n/// @notice Tokenscope ERC20 token registry\ncontract ERC20Registry is Ownable {\n    // This contract stores up to 256 unique facts for each token.\n    // A fact has two parts:\n    //   id: a uint8 value, 0 - 255\n    //   code: a string description of the fact\n    //\n    // Fact codes are not stored on-chain: they are emitted as events\n    // upon creation. Fact ids are assigned in sequential order, and\n    // this contract is only aware of the current highwater fact id,\n    // which defines the list of valid fact ids as 0 through highwater inclusive.\n    //\n    // Each fact code needs to be formulated such that a fact value of '1'\n    // means the fact has been validated by governance.  A fact value\n    // of '0' means the fact has not been validated, so it can be either not true\n    // or not yet validated. Client contract authors special take note of this.\n    //\n    // Each uint8 fact id correlates to the bit-position of a uint256,\n    // so the entire 256 fact-space for a single token can be condensed\n    // into a single uint256. This flattened representation of the entire\n    // fact space is termed a 'factSet'.\n    //\n    // Client contracts can query a set of facts for a token in one of two ways:\n    // - areFactsValidated() accepts an array of uint8 fact ids\n    // - isFactSetValidated() accepts a flattened uint256 factSet\n    // These methods return true IFF all represented facts have been validated.\n    //\n    // Note that isFactSetValidated() will not produce correct results if supplied\n    // with a uint256-casted fact id.  Use factsToFactSet() to convert individual\n    // fact ids to a correct factSet representation.\n\n    // Standard facts\n    uint8 public constant IS_REGISTERED = 0; // Token exists in this contract. Set to 1 when added to registry\n    uint8 public constant IS_VALID_ERC20 = 1; // Token conforms to ERC20 standard. Set by governance\n\n    /// High-water mark for the highest fact id (factSet bit-position)\n    uint8 public highwaterFact = 1;\n\n    /// Maps a token address to its set of validated facts\n    mapping(address => uint256) public tokenFacts;\n\n    /// Emitted when a new fact is created.\n    /// @param fact The unique fact identifer: also the identifier of the fact in token factSets.\n    /// @param code The short descriptive code for this fact.\n    event ERC20FactCreated(uint8 fact, string code);\n\n    /// Emitted when a token's set of validated facts is added/updated\n    /// @param token The token\n    /// @param validatedFacts The new validated fact set of the token\n    event ERC20ValidatedFacts(address indexed token, uint256 validatedFacts);\n\n    /// @param _governor The owning Governance contract\n    constructor(address _governor) {\n        // Governance contract is owner\n        transferOwnership(_governor);\n\n        // factCreated events are the effective \"catalog\" of facts available.\n        // Emit the first to common facts so they show up in the catalog like all the rest.\n        emit ERC20FactCreated(IS_REGISTERED, \"IS_REGISTERED\");\n        emit ERC20FactCreated(IS_VALID_ERC20, \"IS_VALID_ERC20\");\n    }\n\n    /// The token must be registered\n    /// @param _token The token\n    modifier isRegistered(address _token) {\n        require(\n            tokenFacts[_token] & IS_REGISTERED == IS_REGISTERED,\n            \"TOKEN_NOT_REGISTERED\"\n        );\n        _;\n    }\n\n    /// The fact set must only represent facts that have been defined (bit position <= high water mark)\n    /// @param _factSet The fact set\n    modifier validFactSet(uint256 _factSet) {\n        if (highwaterFact < 255) {\n            // The highest valid factSet value would have all bits set to 1 for all created facts.\n            // \"1 << (highwaterFact + 1)\" creates a factSet that exceeds this number by 1:\n            // subtracting one yields the value where all bits are set to 1 for all created facts.\n            require(\n                _factSet <= (1 << (highwaterFact + 1)) - 1,\n                \"INVALID_FACT_SET\"\n            );\n        }\n        _;\n    }\n\n    function _isValidated(address _token, uint256 _factSet)\n        private\n        view\n        returns (bool)\n    {\n        // An individual fact is validated if its bit-position is set to 1.\n        // We can validate multiple facts at once.\n        return tokenFacts[_token] & _factSet == _factSet;\n    }\n\n    /*/////////////////////////////////////////////////////////////////////////////////\n        Registry Administration\n    /////////////////////////////////////////////////////////////////////////////////*/\n\n    /// Create a new fact available for all tokens.\n    /// Existing tokens will have a `false` value for this fact, which can be updated by governance actions\n    /// @param factCode The code for the fact being created\n    /// @dev The fact identifer will be the next available bit-position, according to present `highwaterFact`\n    function createFact(string calldata factCode) external onlyOwner {\n        require(highwaterFact < 255, \"MAX_FACTS_REACHED\");\n\n        emit ERC20FactCreated(++highwaterFact, factCode);\n    }\n\n    /// Add or update an ERC20 token with its set of validated facts.\n    /// @param _token The token\n    /// @param _factSet The set of all validated facts for the token\n    /// @dev If the token already exists, its present factSet will be entirely overwritten by this new value.\n    function addUpdateERC20(address _token, uint256 _factSet)\n        external\n        onlyOwner\n        validFactSet(_factSet)\n    {\n        // The IS_REGISTERED attr is always true in storage\n        //  (1 << IS_REGISTERED) = 1\n        tokenFacts[_token] = _factSet | 1;\n\n        emit ERC20ValidatedFacts(_token, _factSet | 1);\n    }\n\n    /*/////////////////////////////////////////////////////////////////////////////////\n        Registry Querying\n    /////////////////////////////////////////////////////////////////////////////////*/\n\n    /// Convenience method to determine if a particular token exists in this registry\n    /// @param _token The token\n    /// @return bool\n    function tokenIsRegistered(address _token) external view returns (bool) {\n        // Second argument: 1 << IS_REGISTERED = 1\n        return _isValidated(_token, 1);\n    }\n\n    /// Convenience method to determine if a particular token is a valid ERC20 implementation\n    /// @param _token The token\n    /// @return bool\n    function tokenIsValidERC20(address _token)\n        external\n        view\n        isRegistered(_token)\n        returns (bool)\n    {\n        // Second argument: 1 << IS_VALID_ERC20 = 2\n        return _isValidated(_token, 2);\n    }\n\n    /// Return whether specific facts have all been validated for a token.\n    /// @param _token The token\n    /// @param _facts The array of uint8 fact ids to be validated\n    /// @return bool\n    function factsAreValidated(address _token, uint8[] calldata _facts)\n        external\n        view\n        isRegistered(_token)\n        returns (bool)\n    {\n        return factSetIsValidated(_token, factsToFactSet(_facts));\n    }\n\n    /// Return whether a token conforms to a set of facts.\n    /// This method returns true if the token conforms to all flagged facts:\n    /// any facts above and beyond the flagged ones are not accounted for and wil have no impact on the result.\n    /// @param _token The token\n    /// @param _factSet The flattened uint256 fact set to be validated\n    function factSetIsValidated(address _token, uint256 _factSet)\n        public\n        view\n        isRegistered(_token)\n        validFactSet(_factSet)\n        returns (bool)\n    {\n        return _isValidated(_token, _factSet);\n    }\n\n    /*/////////////////////////////////////////////////////////////////////////////////\n        Utility Conversion Methods\n    /////////////////////////////////////////////////////////////////////////////////*/\n\n    /// Convert an array of fact values into a single factSet value\n    /// @dev Does not validate that any particular fact values exist\n    /// @param _facts The array of fact values to convert into a fact set\n    /// @return factSet\n    function factsToFactSet(uint8[] calldata _facts)\n        public\n        pure\n        returns (uint256 factSet)\n    {\n        uint256 len = _facts.length;\n        for (uint256 i = 0; i < len; ++i) {\n            factSet = factSet | (1 << _facts[i]);\n        }\n    }\n\n    /// Convert an factSet value into an array of fact values\n    /// @dev Does not validate that any particular fact values exist\n    /// @param _factSet The fact set to convert into an array of fact values\n    /// @return uint8[]\n    function factSetToFacts(uint256 _factSet)\n        external\n        pure\n        returns (uint8[] memory)\n    {\n        // We can't create a dynamic memory array, so we need to loop twice:\n        // 1) Discover the number of facts. Then we size the facts array appropriately\n        // 2) Populate the facts array\n        uint8 n;\n        uint256 factSetCopy = _factSet;\n\n        // Determine the number of facts\n        for (uint8 i = 0; i < 255; ++i) {\n            if (factSetCopy & 1 == 1) {\n                ++n;\n            }\n            factSetCopy = factSetCopy >> 1;\n        }\n\n        // Size the return array appropriately\n        uint8[] memory facts = new uint8[](n);\n        n = 0;\n        factSetCopy = _factSet;\n\n        // Populate the facts\n        for (uint8 i = 0; i < 255; ++i) {\n            if (factSetCopy & 1 == 1) {\n                facts[n++] = i;\n            }\n            factSetCopy = factSetCopy >> 1;\n        }\n\n        return facts;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}

{
  "language": "Solidity",
  "sources": {
    "contracts/Governor.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\n// Governance Rules\n\n// Proposal Creation:\n// Anyone can create proposal\n// Duplicate proposals are not allowed\n\n// Members:\n// In the constructor, founding members are added.\n// Anyone can create a proposal to add new member or remove existing member.\n\n// Voting\n// Only members can vote\n// There is no castBySig or delegation; each member has to cast a vote by themselves\n// All votes carry equal weight\n// For a proposal to be passed\n//    for votes >= 0.75 * total members\n// We don't keep track of against votes as it doesn't matter, in our case.\n// Because if for votes are > 75 out of 100, against votes are always going to be less than that\n// Inactive vote is a superset of against vote, which additionally allows one to change their vote to true\n// Once quorum is reached, voting is closed.\n\n// Proposal Execution\n// Anyone can execute a proposal once passed\n// Each proposal can be executed only once\n\ncontract Governor {\n    // constants\n    uint256 public constant VOTING_PERIOD = 30 days;\n\n    // variables\n    mapping(address => bool) public members;\n    uint128 public totalMembers;\n    uint128 public quorum;\n\n    struct Receipt {\n        bool hasVoted;\n        bool support;\n    }\n\n    struct Proposal {\n        // slot 1\n        uint128 start;\n        uint128 end;\n        // slot 2\n        bool executed;\n        uint128 forVotes;\n        mapping(address => Receipt) receipts;\n    }\n\n    mapping(uint256 => Proposal) public proposals;\n\n    enum ProposalState {\n        Executed,\n        Active,\n        Succeeded,\n        Defeated\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                      MEMEBERSHIP\n    //////////////////////////////////////////////////////////////*/\n\n    // events\n    event NewMember(address add);\n    event MembershipRemoved(address add);\n\n    // errrors\n    error NotAllowed();\n    error AlreadyMember();\n    error NotAMember();\n\n    constructor(uint128 _quorum, address[] memory foundingMembers) {\n        quorum = _quorum;\n        emit QuorumChanged(0, _quorum);\n\n        uint256 length = foundingMembers.length;\n        for (uint256 i = 0; i < length; ++i) {\n            _addMember(foundingMembers[i]);\n        }\n    }\n\n    function addMember(address _newMember) external {\n        if (msg.sender != address(this)) revert NotAllowed();\n        _addMember(_newMember);\n    }\n\n    function _addMember(address _newMember) internal {\n        if (members[_newMember] != false) revert AlreadyMember();\n        totalMembers++;\n        members[_newMember] = true;\n        emit NewMember(_newMember);\n    }\n\n    function removeMember(address _oldMember) external {\n        if (msg.sender != address(this)) revert NotAllowed();\n        isMember(_oldMember);\n        totalMembers--;\n        members[_oldMember] = false;\n        emit MembershipRemoved(_oldMember);\n    }\n\n    function isMember(address _add) internal view {\n        if (!members[_add]) revert NotAMember();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                      PROPOSAL\n    //////////////////////////////////////////////////////////////*/\n\n    // events\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock\n    );\n    event ProposalExecuted(uint256 proposalId);\n\n    // errors\n    error InvalidProposal(string reason);\n    error RevertForCall(uint256 proposalId, uint256 position);\n    error NotAProposer();\n    error NotSucceededOrAlreadyExecuted();\n    error ProposalAlreadyExecuted();\n\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        Proposal storage p = proposals[proposalId];\n\n        if (p.executed) return ProposalState.Executed;\n        if (p.start == 0) revert InvalidProposal(\"NotDefined\");\n        if (_isSucceeded(p)) return ProposalState.Succeeded;\n        if (p.end >= block.timestamp) return ProposalState.Active;\n        return ProposalState.Defeated;\n    }\n\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public pure returns (uint256) {\n        return\n            uint256(\n                keccak256(abi.encode(targets, values, calldatas, description))\n            );\n    }\n\n    function isValidProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public view returns (uint256 id) {\n        if (targets.length != values.length)\n            revert InvalidProposal(\"targets!=values\");\n        if (targets.length != calldatas.length)\n            revert InvalidProposal(\"targets!=calldatas\");\n        if (targets.length == 0) revert InvalidProposal(\"empty\");\n\n        id = hashProposal(targets, values, calldatas, description);\n\n        if (proposals[id].start != 0) revert InvalidProposal(\"Duplicate\");\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256) {\n        uint256 proposalId = isValidProposal(\n            targets,\n            values,\n            calldatas,\n            description\n        );\n        uint256 _start = block.timestamp;\n        uint256 _end = _start + VOTING_PERIOD;\n        proposals[proposalId].start = uint128(_start);\n        proposals[proposalId].end = uint128(_end);\n\n        emit ProposalCreated(\n            proposalId,\n            msg.sender,\n            targets,\n            values,\n            calldatas,\n            _start,\n            _end\n        );\n        return proposalId;\n    }\n\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) external {\n        uint256 proposalId = hashProposal(\n            targets,\n            values,\n            calldatas,\n            description\n        );\n        // Check\n        if (state(proposalId) != ProposalState.Succeeded)\n            revert NotSucceededOrAlreadyExecuted();\n\n        // Effect\n        proposals[proposalId].executed = true;\n        emit ProposalExecuted(proposalId);\n\n        // Interaction\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{\n                value: values[i]\n            }(calldatas[i]);\n            if (!success) {\n                if (returndata.length == 0) revert RevertForCall(proposalId, i);\n                assembly {\n                    revert(add(32, returndata), mload(returndata))\n                }\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          VOTE\n    //////////////////////////////////////////////////////////////*/\n\n    // events\n    event VoteCast(address indexed voter, uint256 proposalId, bool support);\n    event QuorumChanged(uint128 old, uint128 new_);\n\n    // errors\n    error VotingClosed();\n    error AlreadyVoted();\n    error InvalidQuorum();\n\n    function castVote(uint256 proposalId, bool support) external {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        isMember(voter);\n        if (state(proposalId) != ProposalState.Active) revert VotingClosed();\n\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n\n        if (receipt.hasVoted) revert AlreadyVoted();\n\n        if (support) proposal.forVotes++;\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n\n        emit VoteCast(voter, proposalId, support);\n    }\n\n    function _isSucceeded(Proposal storage proposal)\n        internal\n        view\n        returns (bool)\n    {\n        if (proposal.forVotes * 100 >= totalMembers * quorum) return true;\n        else return false;\n    }\n\n    function changeQuorum(uint128 _newQuorum) external {\n        if (msg.sender != address(this)) revert NotAllowed();\n        if (_newQuorum < 50 || _newQuorum > 100) revert InvalidQuorum();\n\n        emit QuorumChanged(quorum, _newQuorum);\n        quorum = _newQuorum;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
